\section{Introduction}
Humans have always been limited in their capacity and knowledge. There are problems that we cannot solve by brain power alone. The first computers came therefore into existence, made to do tasks that we found too heavy, tedious or even difficult. Today, this has become more of a reliance than ever. Computers has not only become ridiculously faster but are also practically everywhere. Whether we like it or not, it has become essential for a modern society.

However, the problem with computers, just like it was aeons ago, is that it still needs to be told what to do. If a problem is too difficult for us to describe precisely, it cannot solve it. Even if we do manage to program it to solve a very difficult problem, it may use too much resources. Sometimes, it is better to get an estimation of the answer. A genetic algorithm is a search method that has this ability. It may not find optimal results but more often than not, the results are sufficiently satisfactory for given problem. This comes in handy when thorough search is too costly or not possible.

While this method has been applied in many applications already, there are still aspects of it that need to be addressed. One major concern is that of scalability. The most common way to map a genotype to phenotype, as it was back in the beginning, is often directly. An alteration in a single trait in the genotype had a direct effect on traits in the phenotype. For small applications, this method is sufficiently efficient. However, as problems increase in size and complexity, the genotype too will grow larger and more complex. Eventually, it will become computationally infeasible as well.

Since genetic algorithms are inspired by natural selection, it is only obvious that possible solutions to the scalability problem could also stem from biology. If we look at how some organisms came to be, we know that most of these start out as a single cell. The cell divides and become two cells. These cells divides once more two become four, and this process is kept going until it reaches maturity. The whole process is coordinated with the help of the DNA and some interactions. This is nature's way to tackle the scalability problem. Drawing inspiration from genome and cellular activities, many development models have been created. Whether they make use of a DNA or applies a different approach, they all inherit the idea of a single entity, duplicating itself until a whole organism is grown to a satisfactory size and shape. As it turns out, it was difficult to learn from these models. It was hard to determine what worked, or didn't. It seemed that every model had its own quirks, showing that some properties are beneficial while others claimed the opposite. How do we then know what is right and what is wrong? What factors had an effect on the models? How do we know it is not the model that is at fault but a smaller detail somewhere else?

This thesis does not seek to answer such questions. Instead, it wishes to make them disappear by introducing a common platform on which models can be implemented. If all models utilized a common platform, many trivial factors will disappear simply because of the fact that any model implemented within this framework will use the same implementation for anything that is common in artificial development, save the model itself. As the thesis goes on, this will hopefully become much clearer. By providing a common ground, the focus will shift away from the underlying structure, to the models themselves. The requirements of such a framework will come to light in the following chapters.

\subsection{Biological Development}
Biological development is a term used to describe the process where organisms grow and develop. In humans, for example, the process in which a fertilized egg grows and develops into a fetus is an area that is studied in biological development. This process can be applied to computer science but instead of organisms, it may be a picture, a solution to a problem, or even software to control a robot.

The following listing is compiled words, and their meaning, that are commonly used when discussing artificial development in general and particularly in this thesis.

\begin{itemize}
\itemsep=0pt
	\item\textbf{ADCGP} or artificial development is the shorter name for \emph{artificial development using Cartesian genetic programming}. Method and model invented by Dr. Julian F. Miller. A cell program based model.
	\item\textbf{ArtDev3D} is the other model discussed in this thesis. Written by Johan H{\o}ye for his master's thesis. A DNA based model.
	\item\textbf{Cell program} is the program of a cell. However, it losely used as a term for the cellular activities that take place in a development step when talking about the framework.
	\item\textbf{Development step} or \textbf{tick} is a single unit of growth. With each step, cells partake in activities that contribute to the growth of an organism.
	\item\textbf{Evolutionary algorithm} is a search method inspired by biology and applies concepts of reproduction, mutation and selection to computers.
	\item\textbf{Genetic algorithm} is a class of evolutionary algorithms that are often used to solve optimization problems
	\item\textbf{Genetic programming} is another class of evolutionary algorithms. This technique is applied when trying to find an algorithm that is able to solve some predefined tasks.
	\item\textbf{Genotype} is the genetics of an organism. It is the ``recipe'' for an organism.
	\item\textbf{Organism} refers to the entity that contains a genotype and cells. The state of an organism starts out with a single cell to ``fully'' grown.
	\item\textbf{Phenotype} is the end result of a genotype. It is the resultant organism that we see when it is fully grown.
\end{itemize}

\subsection{Motivation}
While evolutionary computation has been around for a while, artificial development is still at an early stage. There is still a lot to study in this field. Though researchers have already made great progress in this field, there are things that aren't quite figured out yet. When ArtDev3D was presented two years ago, it created a controversy because it showed that chemicals weren't all that beneficial to development. This was direct contradiction to other articles in the field. For a couple of years already, chemicals have shown to be beneficial when working with artificial development. However, it was then later discovered that chemicals were used differently in these models. While chemicals were used to exchange information between cells, ArtDev3D only used it internally to activate proteins. There may also have been other factors that affected this outcome, though it was fairly difficult to determine. This only raised more questions than there were answers for. Of course, more thorough studies could have been done but these models were built on different platforms as well. Any study of these would have to take into account too many factors to give reliable results.

One may then ask if there isn't anything that can be done to make these uncertainties go away. First of all, it is nearly impossible to remove any uncertainty, as this will always be present to some extent. However, it is entirely possible to reduce the number of factors such that the equation balances out. This can be achieved by introducing a common ground that every model will share except for what makes it unique. Just like how an operating system provides all the necessary infrastructure so that different softwares can be useful to us, a similar platform should also exist to provide any development model what is needed. Such a platform will not eliminate factors but make the factors not matter because they are the same for all models. All cells will have the same definition in all models. All models will use the same development algorithm. The focus shift to the models will clearly show what the differences are, hopefully making studies of this nature even more fruitful than it has been thus far.

\subsection{Where do we go from here?}
In the following chapter, we will have a look at the two models that have been chosen for this project. We will look at the idea behind them and see how they work. We will also discuss their differences and explain why a framework is necessary. We will also be looking at requirements for such a framework. In chapter~\ref{sec:implementation}, we shall take a look at the implementation of the framework and the porting of mentioned models over to the framework. This section will describe the most important details that is relevant to their re-implementation. Any changes made during this process will be highlighted and explained. With chapter~\ref{sec:experiments}, it will be shown that it is possible to reproduce the results gotten in past experiments. Some experiments will be picked out and tested on the new implementations of two models. The results are then compared and discussed. This is a necessary step in order to prove that it is in fact possible to implement different models within the framework.
