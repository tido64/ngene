\section{Introduction}
Humans have always been limited in their capacity and knowledge. There are problems that we cannot solve by brain power alone. The first computers came therefore into existence, made to do tasks that we found too heavy, tedious or even difficult. Today, this has become more of a reliance than ever. Computers has not only become ridiculously faster but also practically everywhere. Whether we like it or not, it has become essential for a modern society.

However, the problem with computers, just like it was aeons ago, is that it still needs to be told what to do. If a problem is too difficult for us to describe precisely, it cannot solve it. Even if we do manage to program it to solve a very difficult problem, it may use too much resources. Sometimes, it is better to get an estimation of the answer. A genetic algorithm is a search method that has this ability. It may not find optimal results but more often than not, the results are sufficiently satisfactory for given problem. This comes in handy when thorough search is too costly or not possible.

While this method has been applied in many applications already, there are still aspects of it that need to be addressed. One major concern is that of scalability. The most common way to map a genotype to phenotype, as it was back in the beginning, is often directly. An alteration in a single trait in the genotype had a direct effect on traits in the phenotype. For small applications, this method is sufficiently efficient. However, as problems increase in size and complexity, the genotype too will grow larger and more complex. Eventually, it will become computationally infeasible as well.

Since genetic algorithms are inspired by natural selection, it is only obvious that possible solutions to the scalability problem could also stem from biology. Drawing inspiration from genome and cellular activities, many development models have been created but it is difficult to learn from it. How can we see what works and what doesn't? When these models are built individually, on different platforms, how do we then know what is right when they give contradictory results? How do we know it is not the model that is at fault but a smaller detail somewhere else?

This thesis does not seek to answer such questions. Instead, it proposes a common platform on which models can be implemented. This framework is an attempt at minimizing the impact of trivial factors related to the system that may influence the conclusion of a comparison. The focus should lie on the models and not the underlying structure upon which it was implemented. The requirements of such a framework will come to light in the following chapters.

\subsection{Biological Development}
Biological development is a term used to describe the process where organisms grow and develop. In humans, for example, the process in which a fertilized egg grows and develops into a fetus is an area that is studied in biological development. This process can be ``applied'' to computer science but instead of organisms, it may be a picture, a solution to a problem, or even software to control a robot.

The following listing is compiled words, and their meaning, that are commonly used when discussing artificial development in general and particularly in this thesis.

\begin{itemize}
\itemsep=0pt
	\item\textbf{ADCGP} or artificial development is the shorter name for \emph{artificial development using Cartesian genetic programming}. Method and model invented by Dr. Julian F. Miller.
	\item\textbf{ArtDev3D} is the other model discussed in this thesis. Written by Johan H{\o}ye for his master's thesis.
	\item\textbf{Cell program} is losely used as the cellular activities that takes place in a development step. This can be anything from reacting to external stimula to cell division.
	\item\textbf{Development step} or \textbf{tick} is a single unit of growth. With each step, cells partake in activities that contribute to the growth of an organism.
	\item\textbf{Evolutionary algorithm} is a search method inspired by biology and applies concepts of reproduction, mutation and selection to computers.
	\item\textbf{Genetic algorithm} is a class of evolutionary algorithms that are often used to solve optimization problems
	\item\textbf{Genetic programming} is another class of evolutionary algorithms. This technique is applied when trying to find an algorithm that is able to solve some predefined tasks.
	\item\textbf{Genotype} is the genetics of an organism. It is the ``recipe'' for an organism.
	\item\textbf{Organism} refers to the entity that contains a genotype and cells. The state of an organism starts out with a single cell to ``fully'' grown.
	\item\textbf{Phenotype} is the end result of a genotype. It is the resultant organism that we see when it is fully grown.
\end{itemize}

\subsection{Motivation}
While evolutionary computation has been around for a while, artificial development is still pretty young. There is still a lot to learn in this field. Though researchers have already made great progress in this field, there are things that aren't quite figured out yet. When ArtDev3D was presented two years ago, it created a controversy because it showed that chemicals weren't all that beneficial to development. This was the opposite result of what has been shown to work for a couple of years already. However, it was later shown that chemicals were used differently in these models. While chemicals were used to exchange information between cells, ArtDev3D only used it internally to activate proteins. There may also have been other factors that affected the outcome, though this was fairly difficult to determine. In an ideal world, this would have happened differently. The results would've been unambiguous, it would be definite instead of a maybe.

One may ask if there isn't anything that can be done to make these uncertainties go away. This can be a difficult task to accomplish but there are certain factors that can be removed in order to balance the equation. Just like how an operating system provides a foundation that any software can be created an launched, a similar platform can be implemented to provide the development models with what is needed. Such a platform, though it sounds highly ambitious at the moment, could potentially help everybody learn more from other models.

\subsection{Where do we go from here?}
In the following chapter, we will have a look at the two models that have been chosen for this project. We will look at the idea behind them and see how they work. We will also discuss their differences and explain why a framework is necessary. We will also be looking at requirements for such a framework. In chapter~\ref{sec:implementation}, we shall take a look at the implementation of the framework and the porting of mentioned models over to the framework. This section will describe the most important details that is relevant to their re-implementation. Any changes made during this process will be highlighted and explained. With chapter~\ref{sec:experiemts}, it will be shown that it is possible to reproduce the results gotten in past experiments. Some experiments will be picked out and tested on the new implementations of two models. The results are then compared and discussed. This is a necessary step in order to prove that it is in fact possible to implement different models within the framework.
